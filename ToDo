Test commit

- Final 2nd test results:
    - initProj, yes.
    - commitFile, .
    - addBranch, yes.
    - getBranches, .
    - getFiles, .
    - deleteBranch, 
    - deleteFile, 
    - fileCommitHistory, 
    - branchCommitHistory, 
    - checkoutBranch, 
    - gitGraph, 
    - diffFiles, 
    - diffForCommit, . 
    - downloadRepo, 
        -- Only keeping this for now. This route works and returns .zip in "res.download"
    - readFile, .
    - fixConsistency, 
    - mergeFiles, 
    - pushChecker - works same as /mergeFiles except it's just `git pull origin srcBranch`.
    - deleteProj, yes. 

- Routes whose test remain:


1. projName and majorHash in an object to be returned back to blockchain.

2. (Inform Gopi) 
    authorname = participantCard's Identifier (i.e. get name) and 
    authoremail and
    branchName (i.e. on which branch the user is currently performing the route actions)
    => should be kept in world state 

3. Features remaining:
    - (SCRAPPED): issues (Relevant ToDo - 4, issues-datastructure.json)
    - (Future - optional): Restore a branch.
    - (Future - optional): Public repos, issues.

After devOnCLI pushed changes and devOnRemote is working on the repository,
    [System checks] If pushed change is not conflicting,
        git commit to create a new commit.
    [System checks] If pushed change is a conflicting one (i.e. the latest (pushed) commit has updated the same file which was being edited remotely),
        [ System allows user to look at the diff patch of what changed ] [ System is currently in merge state - after pulling ]
        If user is okay with proceeding with commit, 
            System allows user to proceed with completing this merge by: `git checkout --ours .` && git commit -m "commit msg"
                    { Remember this will not erase 'theirs' changes because unka change already committed hai }
                    { Thus a new merge commit - but with user provided commit msg is created }


- Final pointers:
 - System will allow creation of projects by anyone. 
 - Folder structure will made as:
    projects/
        projectName1.git (if it not exists, bring from IPFS)
        projectName1/ (if it not exists, clone it out from bare)
            branchName/ (scanning point here - fs.readdir and perform the algo steps defined at end of this file.)
                username+timestamp 
 - (Utility - rmWorkdir(username)) Delete username folder under projectName folder whenever user's actions are completed (when route is about to end)
 - Operations:
        a. setup the directory structure.
        b. perform git operations.
        c. after ops, run Checker.
            if (Checker does not show conflicts):
                push changes to project's bare folder. (pass the filename_arr as well - here it will be empty)
            if (Checker shows conflicts):
                Remove timestamp from username's folder (workdirpath).
                take the filename_arr and buffer of those files and pass it.
        d. Remove username folder (utility as mentioned above) 
 - When user wants to merge, 
    a. execute mergeFiles route. 
        -- if conflicts arise (filename_arr is not empty - filled with file names):
            Remove timestamp from username's folder (workdirpath).
            Pass the filename_arr and all the buffers of the respective files.
            if user wants to perform other operations (means while he is in merge state): (add a check at each route to know whether same user ka folder exists or not)
                if it exists, throw err: "<git ka error>"
        -- if no conflicts exist,
                directly push to bare.
 - pushChecker:
    - Check between bare repo status and username work dir status
    - Utility.
        - `git pull barerepo master`
        - if conflicts arise, { do the same that you did for mergeFiles route when conflicts arise }.
        - if conflicts dont arise, pull will be successful.

 - statusChecker:
    - `git fetch`
    - `git status`
        - Extract the line the "This branch is ahead / behind n commits ...."

 - (Merge Conflict page):
    if user wants to work on CLI (Show URL / Download Repo),
        downloadRepo route:
            zip the work dir of user.
            send the zip.
            Remove user's work dir.


getFiles shell script:
credits: https://stackoverflow.com/questions/17359370/git-show-last-commit-date-and-message-for-each-file-in-directory-like-github/17361406#17361406

modified for my use case:
FILES="$(git ls-tree --name-only HEAD .)";IFS="$(printf "\n\b")";for f in $FILES; do    str="$(git log -1 --pretty=format:"%s%x28%x7c%x29%x2D%x7c%x2D%x28%x7c%x29%cr" $f)";  printf "%s-%s\n" "$f" "$str"; done


====================================================== Modified workflow: ===========================================

  - projName/
    - branchName/ branchNamepath
       - username+timestamp (workdirpath)

Both are same:
getMergeArr - utility
getMergeArr - route (takes branchNamepath)
- output:
   merge_arr = [
                    {  
                        mergeid: username+timestamp, (dir_list[i])
                        file: filename_list,
                        title: ''
                    },
                    {
                        mergeid: username+timestamp, 
                        file: filename_list,
                        title: ''
                    }
               ]
readMerge - route (takes username+timestamp i.e. in this case, workdirpath)
- output:
    filebuffobj

mergeCommit - route (don't create new username+timestamp -> the mergeid whose value will be provided, branchName, filebuffobj)
                - FIRST ITERATE THE filebuffobj;
                - SECOND ADD (fs.writeFile and git.add) all files' buffer
                - THIRD Perform Commit ONCE to complete merge state.
                - pushChecker cases:
                    if (conflicts occur from pushChecker):
                        Return filebuffobj
                    if (conflicts do not occur from pushChecker):
                        Delete username+timestamp folder under branchName/

- if conflict occurs, do not remove workdirpath and perform scanDir utility.
- if conflict does not occur (if operation successful and removing user's operated directory), perform scanDir utility. (should be performed after route operations + IPFS)

merge_arr = [
                {  
                    'mergeid': username+timestamp (dir_list[i]), 
                    'file': filename_list
                },
                {
                    'mergeid': username+timestamp (dir_list[i]),
                    'file': filename_list
                }
            ]

for all operations, send this below array
{
    "normal": merge_arr,
    "special": [ // When a conflict which is not 'content' is detected, put the formed merge obj into the merge arr and pass this main obj out
                {  
                    'mergeid': username+timestamp (dir_list[i]), 
                    'instructions': [],
                    'title':''
                },
                {
                    'mergeid': username+timestamp (dir_list[i]),
                    'instructions': [],
                    'title':''
                }
            ]
}

Route flow:
main_op
{} = await pushChecker - give a response object as { statusLine, ipfsHash, mergeObj}:
    try {
    - git pull
    - if (conflict present)
        - if (conflict_line) 
            - throw new Error("conflict")
    - pushToBare
    - removeFromIPFS(old_ipfsHash)
    - addToIPFS
    - statusChecker.
    - rmWorkdir
    - getMergeArr
    } catch(e) {
        if (e === "conflict")     
            - statusChecker 
            - getMergeArr 
    }
res.send
{
    "mergeid": "adi nambiar1588928408265",
    "filenamelist": [
        "a"
    ],
    "title": "Merge conflict raised when merging origin/f0 into master"
},
{
    "mergeid": "raj mandal1588927956876",
    "filenamelist": [
        "a"
    ],
    "title": "Merge conflict raised when merging origin/f0 into master"
}

getMergeArr in pushChecker - sequence:
scanDir - to fetch directory listing
read JSON file first to fetch type.
compare the type (as written below)
According to type, perform the operations (as written below)
Form the mergeArr

for mergeBranches route (don't involve pushChecker in this) (just pass the error the with status 400 - "conflicting merge, pls check merge conflicts" - that conflict occured - because getFiles will be sending merge array)
    git merge branchName
        -- mergeid will be the username and current timestamp value (workdirpath)
        -- filename_list of the workdirpath in which conflicts occured.
     -- git merge branchName
    on any content conflict,
        - create json file with the name same as the current directory. 
        - of the form: {
                type: 'branch',
                title: <form appropriate tile mentioning both the branch names> 
        }
    on any special conflict, 
        - ... same as content conflict.
        - only keep ... type: 'special' ...
for pushChecker's getMergeArr:
        - read the json file and fetch type and title. 
        - set the title value in merge arr object (which is in process)
        - Compare the type:
            1. if type === "pull" / type !== "branch":
                perform `git merge --abort`
                then git pull origin  
            2. if type !== "pull" / type === "branch":
                fetch filename_list (git diff wala command)
            3. if type === "special":
                set the instructions array.


Create a new route downloadAndRemoveRepo(mergeid):
    -- take mergeid
    -- zip that folder.
    -- remove the folder of this name (branchNamepath/mergeid).

=========================CLIENT DOCUMENT ROUTES=========================
 - DONE.
IPFS create:
    - get fileArr
    - return majorHash

IPFS getFileNameArr:
    - get majorHash (ls -able)
    - return { filename: }

IPFS getFileBuffObj:
    - get ipfsFileHash
    - return { filename:buffer }

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
ISSUES IN ROUTES CURRENTLY:
- addBranch:
    -- isomorphic-git's add branch operation is not throwing error as it does on web UI.
     --- Fixed that, had to manually throw an error when creating branchName folder.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


===========================================================================

Different types of 'special' conflicts can be found on this C code:


https://github.com/git/git/blob/master/merge-recursive.c


Press ctrl+f and type "conflict ("
At the time of writing this, there are around 15 to 16 conflict types (which are other than content type conflict)
