- Final 2nd test results:
    - initProj, yes.
    - commitFile, .
    - addBranch, .
    - getBranches, .
    - getFiles, .
    - deleteBranch, 
    - deleteFile, 
    - fileCommitHistory, 
    - branchCommitHistory, 
    - checkoutBranch, 
    - gitGraph, 
    - diffFiles, 
    - diffForCommit, . 
    - downloadRepo, 
        -- Only keeping this for now. This route works and returns .zip in "res.download"
    - readFile, .
    - fixConsistency, 
    - mergeFiles, 
    - pushChecker - works same as /mergeFiles except it's just `git pull origin srcBranch`.
    - deleteProj, yes. 

- Routes whose test remain:


1. projName and majorHash in an object to be returned back to blockchain.

2. (Inform Gopi) 
    authorname = participantCard's Identifier (i.e. get name) and 
    authoremail and
    branchName (i.e. on which branch the user is currently performing the route actions)
    => should be kept in world state 

3. Features remaining:
    - (SCRAPPED): issues (Relevant ToDo - 4, issues-datastructure.json)
    - (Future - optional): Restore a branch.
    - (Future - optional): Public repos, issues.

After devOnCLI pushed changes and devOnRemote is working on the repository,
    [System checks] If pushed change is not conflicting,
        git commit to create a new commit.
    [System checks] If pushed change is a conflicting one (i.e. the latest (pushed) commit has updated the same file which was being edited remotely),
        [ System allows user to look at the diff patch of what changed ] [ System is currently in merge state - after pulling ]
        If user is okay with proceeding with commit, 
            System allows user to proceed with completing this merge by: `git checkout --ours .` && git commit -m "commit msg"
                    { Remember this will not erase 'theirs' changes because unka change already committed hai }
                    { Thus a new merge commit - but with user provided commit msg is created }


- Final pointers:
 - System will allow creation of projects by anyone. 
 - Folder structure will made as:
    projects/
        projectName1.git (if it not exists, bring from IPFS)
        projectName1/ (if it not exists, clone it out from bare)
            branchName/ (scanning point here - fs.readdir and perform the algo steps defined at end of this file.)
                username+timestamp 
 - (Utility - rmWorkdir(username)) Delete username folder under projectName folder whenever user's actions are completed (when route is about to end)
 - Operations:
        a. setup the directory structure.
        b. perform git operations.
        c. after ops, run Checker.
            if (Checker does not show conflicts):
                push changes to project's bare folder. (pass the filename_arr as well - here it will be empty)
            if (Checker shows conflicts):
                Remove timestamp from username's folder (workdirpath).
                take the filename_arr and buffer of those files and pass it.
        d. Remove username folder (utility as mentioned above) 
 - When user wants to merge, 
    a. execute mergeFiles route. 
        -- if conflicts arise (filename_arr is not empty - filled with file names):
            Remove timestamp from username's folder (workdirpath).
            Pass the filename_arr and all the buffers of the respective files.
            if user wants to perform other operations (means while he is in merge state): (add a check at each route to know whether same user ka folder exists or not)
                if it exists, throw err: "<git ka error>"
        -- if no conflicts exist,
                directly push to bare.
 - pushChecker:
    - Check between bare repo status and username work dir status
    - Utility.
        - `git pull barerepo master`
        - if conflicts arise, { do the same that you did for mergeFiles route when conflicts arise }.
        - if conflicts dont arise, pull will be successful.

 - statusChecker:
    - `git fetch`
    - `git status`
        - Extract the line the "This branch is ahead / behind n commits ...."

 - (Merge Conflict page):
    if user wants to work on CLI (Show URL / Download Repo),
        downloadRepo route:
            zip the work dir of user.
            send the zip.
            Remove user's work dir.


getFiles shell script:
credits: https://stackoverflow.com/questions/17359370/git-show-last-commit-date-and-message-for-each-file-in-directory-like-github/17361406#17361406

modified for my use case:
FILES="$(git ls-tree --name-only HEAD .)";IFS="$(printf "\n\b")";for f in $FILES; do    str="$(git log -1 --pretty=format:"%s%x28%x7c%x29%x2D%x7c%x2D%x28%x7c%x29%cr" $f)";  printf "%s-%s\n" "$f" "$str"; done

  - projName/
    - branchName/ branchNamepath
       - username+timestamp (workdirpath)

Both are same:
scanDir - utility (same as getMergeArr)
getMergeArr - route (takes branchNamepath)
- output:
   merge_arr = [
                    {  
                        'mergeid': username+timestamp, (dir_list[i])
                        'file': filename_list
                    },
                    {
                        'mergeid': username+timestamp, 
                        'file': filename_list
                    }
               ]
readMerge - route (takes username+timestamp i.e. in this case, workdirpath)
- output:
    filebuffobj

mergeCommit - route (don't create new username+timestamp -> the mergeid whose value will be provided, branchName, fileArr (filenamearr formatted))
                - FIRST ITERATE THE fileArr
                - SECOND ADD (fs.writeFile and git.add) all files' buffer
                - THIRD Perform Commit ONCE to complete merge state.
                - pushChecker cases:
                    if (conflicts occur from pushChecker):
                        Return filebuffobj
                    if (conflicts do not occur from pushChecker):
                        Delete username+timestamp folder under branchName/

- if conflict occurs, do not remove workdirpath and perform scanDir utility.
- if conflict does not occur (if operation successful and removing user's operated directory), perform scanDir utility. (should be performed after route operations + IPFS)
< perform checkUnmergedPath.js utility on username+timestamp folder - fetch filenamearr >
 
for all operations, send this below array
merge_arr = [
                {  
                    'mergeid': username+timestamp (dir_list[i]), 
                    'file': filename_list
                },
                {
                    'mergeid': username+timestamp (dir_list[i]),
                    'file': filename_list
                }
            ]

{
    "normal": merge_arr,
    "special": [
                {  
                    'mergeid': username+timestamp (dir_list[i]), 
                    'instructions': []
                },
                {
                    'mergeid': username+timestamp (dir_list[i]),
                    'instructions': []
                }
            ]
}

main_op
pushChecker - fetch merge_arr:
    try {
    - git pull
    - if (conflict present)
        - if (conflict_line) 
            - throw new Error("conflict")
    - git push (if successful) - pushToBare
        - scanDir - to form a path.
        - statusChecker.
        - rmWorkdir
        - getMergeArr
    } catch(e) {
        if (e === "conflict")     
            - scanDir - to form a path.
            - statusChecker 
            - getMergeArr 
    }
<IPFS_work>